%!PS-Adobe-3.0 EPSF-3.0
%%Creator: PSTricks
%%Title: rahmen.eps
%%CreationDate: 2011/3/1
%%BoundingBox: -13 -13 150 96
%%EndComments
%%BeginProcSet: pstricks.pro
% $Id: pstricks.pro 455 2011-01-30 11:19:19Z herbert $ 
% 
%% PostScript prologue for pstricks.tex. 
%% Version 1.07, 2009/04/30 
%% 
%% This program can be redistributed and/or modified under the terms 
%% of the LaTeX Project Public License Distributed from CTAN archives 
%% in directory macros/latex/base/lppl.txt. 
% 
% 
% Define the follwing gs-functions if not known, eg when using distiller 
% 
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if 
systemdict /.setblendmode known not {/.setblendmode { pop } def } if 
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if 
% 
/tx@Dict 200 dict def  % the main PSTricks dictionary 
tx@Dict begin 
/ADict 25 dict def % The arrow dictionaray 
/CM { matrix currentmatrix } bind def 
/SLW /setlinewidth load def 
/CLW /currentlinewidth load def 
/CP /currentpoint load def 
/ED { exch def } bind def 
/L /lineto load def 
/T /translate load def 
/TMatrix { } def 
/RAngle { 0 } def 
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known 
/ATAN1 {neg -1 atan 180 sub } def % atan(x) (only one parameter) 
/Div { dup 0 eq { pop } { div } ifelse } def   % control the division 
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 }  % return 1.e10 as infinit 
  { dup sin exch cos div } ifelse  % default sin/cos 
} def 
/Tan { dup sin exch cos Div } def  % sin(x)/cos(x) x in degrees 
/Acos {dup dup mul neg 1 add dup 0 lt { % arc cos, returns 0 when negative root 
  pop pop 0 }{ sqrt exch atan} ifelse } def 
/NET { neg exch neg exch T } def        % change coordinate system to the negative one 
/Pyth { dup mul exch dup mul add sqrt } def    % Pythagoras, expects 2 parameter 
/Pyth2 { % Pythagoras, xA yA xB yB 
  3 -1 roll  % xA xB yB yA 
  sub % xA xB yB-yA 
  3 1 roll  % yB-yA xA xB 
  sub % yB-yA xA-xB 
  Pyth } def 
/PtoC { 2 copy cos mul 3 1 roll sin mul } def  % Polar to Cartesian 
/Rand { rand 4294967295 div } def % a real random number 
%----------------- hv added 20050516 --------------- 
/PiDiv2 1.57079632680 def 
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def 
/Euler 2.71828182846 def 
%/e Euler bind def 
% 
/RadtoDeg { 180 mul Pi div } bind def  % convert from radian to degrees 
/DegtoRad { Pi mul 180 div } bind def  % viceversa 
%----------------- hv end--------------------------- 
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def 
% 
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def } 
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ } 
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def 
% 
/STP { .996264 dup scale } def % BP/PT scaling 
/STV { SDict begin normalscale end STP  } def % 
% 
/DashLine { 
    dup 0 gt 
    { /a .5 def PathLength exch div } 
    { pop /a 1 def PathLength } ifelse 
    /b ED % pattern should fit evenly in b 
    dup /X ED % pattern array 
    0 get /y ED % length of first black segment 
    /z 0 X {add} forall def % length of the full pattern 
    %% Computation of the scaling factor as described by van Zandt: 
    b a .5 sub 2 mul y mul sub z Div round 
    z mul a .5 sub 2 mul y mul add b exch Div 
    %%%% scaling factor on stack. 
    /z ED %% now, z is the scaling factor 
    false % for the length test below 
    X { z mul } forall X astore %% modification TN 04-08-07 
    %%% Checking whether at least one dash in X has positive length: 
    {0 gt or} forall 
    { X 1 a sub y mul } 
    { [ 1 0 ] 0 } 
    ifelse 
    setdash stroke 
} def 
% 
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def 
% 
/SymbolLine {   % on stack [ x y x y ... 
  counttomark  % number of elements 
  2 div cvi /n ED      % n pairs 
  /YA ED /XA ED % the start point 
  n 1 sub { 
    /YB ED /XB ED 
    /XLength XB XA sub def 
    /YLength YB YA sub def 
    /PAngle YLength XLength Atan def 
    /XYLength XLength YLength Pyth def 
    /nSym XYLength SymStep div cvi def 
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def 
    /deltaY YLength nSym div def 
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if 
      Symbol show 
      grestore 
      deltaX deltaY rmoveto 
    } repeat 
    /YA YB def /XA XB def 
  } repeat 
  XA Shift sub YA Shift sub moveto 
  gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if 
  Symbol show grestore 
  pop  % delete the mark symbol 
} def 
% 
/LineFill { % hv ------------ patch 7 ------------- 
  gsave 
  abs /hatchWidthInc ED 
  abs /hatchSepInc ED 
  abs CLW add /a ED 
  a 0 dtransform round exch round exch 
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict 
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def 
      CLW hatchWidthInc add SLW 
    } if 
  } repeat 
  grestore 
  pop pop } def 
% 
/PenroseFill {%  on stack: scaling factor 
  dup dup scale 
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch 
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict 
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul} 
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall 
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto 
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25 
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def 
% 
/TruchetFill { %  on stack: scaling factor 
  10 dict begin 
  dup dup scale 
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch 
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict 
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def 
  /ha a 2 div def 
  /mha ha neg def 
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if 
    mha mha moveto ha mha lineto 
    ha ha lineto mha ha lineto 
%    closepath .1 setlinewidth stroke 
    contents 
  } def 
  /contents{ 
    0 ha moveto ha 0 lineto 
    0 mha moveto mha 0 lineto 
%    1 setlinewidth stroke 
  } def 
  /dotiling { 
    f ma mul a f a mul { 
      /i exch def 
      f ma mul a f a mul { 
        /j exch def 
        gsave i j translate 
        tile stroke grestore 
      } for 
    } for 
  } def 
% 
  /f 3 def 
  5 srand dotiling 
  end % local user dict 
} def 
% 
/BeginArrow { 
  ADict begin  % hold it local, for end see EndArrow 
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def 
% 
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict 
% 
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def 
% 
/ArrowD { % the sides are drawn as curves (hv 20071211) 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction 
% we use y=w/h^2 * x^2 as equation for the control points 
% for the coordinates the arrow is seen from top to bottom 
% the bottom (tip) is (0;0) 
  w neg h moveto % lower left of > 
  w 9 div 4 mul neg h 3 div 2 mul 
  w 9 div neg       h 3 div 
  0 0 curveto    % tip of > 
  w 9 div        h 3 div 
  w 9 div 4 mul  h 3 div 2 mul 
  w h curveto % upper left of > 
  w neg Inset neg rlineto % move to x=0 and inset 
  gsave fill grestore 
} def 
% 
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def 
% 
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def 
% 
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def 
% 
/SD { 0 360 arc fill } def 
% 
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse   % outer or inner dimen 
  /b ED  % the color definition 
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def 
% 
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } { 
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto 
  load } if ] cvx newpath 3 1 roll T exec } def 
% 
/NArray { % holds the coordinates and on top of stack the showpoints boolean 
  /showpoints ED 
  counttomark 2 div dup cvi /n ED   % n 2 div on stack 
  n eq not { exch pop } if % even numbers of points? delete one 
  showpoints 
    { ] aload /Points ED } 
    { n 2 mul 1 add -1 roll pop } ifelse % delete the mark symbol 
} def 
% 
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def 
% 
/LineToYAxis { 
  NArray            % all x-y pairs on stack 
  n { 2 copy moveto % go to current point 
    0 exch Lineto   % line to y-axis 
    pop             % delete old x-value 
  } repeat 
} def 
% 
/LineToXAxis{ 
  NArray % all x-y pairs on stack 
  n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if 
      ArrowA 
      /n n 2 sub def 
      CP 2 copy moveto pop 0 Lineto 
      n { 2 copy moveto pop 0 Lineto } repeat 
      CP 
      4 2 roll 
      ArrowB 
      2 copy moveto pop 0 
      L 
      pop pop } if 
} def 
% 
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def 
% 
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq 
  and { pop pop /n n 1 sub def } if 
} def 
% 
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED 
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto 
      Lineto pop pop closepath } ifelse 
} def 
% 
/SymbolPolygon {   % on stack [ x y x y ... 
  counttomark  % number of elements 
  2 add /m ED 
  2 copy m 2 roll % copy last two 
  m 2 div cvi /n ED     % n pairs 
  /YA ED /XA ED % the start point 
  n 1 sub { 
    /YB ED /XB ED 
    /XLength XB XA sub def 
    /YLength YB YA sub def 
    /PAngle YLength XLength Atan def 
    /XYLength XLength YLength Pyth def 
    /nSym XYLength SymStep Div cvi def 
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def 
    /deltaY YLength nSym Div def 
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if 
      Symbol show 
      grestore 
      deltaX deltaY rmoveto 
    } repeat 
%    XB Shift sub YB Shift sub moveto Symbol show 
    /YA YB def /XA XB def 
  } repeat 
  pop % delete the mark symbol 
} def 
% 
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def 
% 
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx 
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis) 
% setmatrix } def 
  setmatrix pop 
} def 
% DG/SR modification end 
% 
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def 
% 
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def 
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def 
% 
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def 
% 
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def 
/NC { CC x1 y1 x2 y2 x y curveto } def 
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def 
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def 
/NAC { x2 y2 x y curveto CC x1 y1 } def 
/EAC { x2 y2 x y ArrowB curveto pop pop } def 
% 
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def 
% 
/CurvePath { 
  flattenpath /z 0 def /z0 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    startAngle rotate Symbol show 
    grestore /z0 z def } 
  { /y ED /x ED PathLength@ z z0 sub SymStep ge { 
      x Shift sub y Shift sub moveto 
      gsave 
      rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if 
      Symbol show 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} 
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave 
    rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if 
    Symbol show 
    grestore 
  } 
  pathforall 
  z 
} def 
% 
/OpenSymbolCurve { 
  OpenCurve 
  0.1 setflat 
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def 
% 
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload 
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def 
% 
/AltOpenSymbolCurve { 
  AltCurve 
  0.1 setflat 
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def 
% 
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def 
% 
/ClosedSymbolCurve { 
  ClosedCurve 
  0.1 setflat 
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def 
% 
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def 
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def 
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def 
% 
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix 
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def 
% 
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto 
  x1 y1 lineto 
  closepath 
} def 
% 
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse 
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto 
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def 
% 
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def 
% 
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def 
% 
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def 
% 
/OpenSymbolBezier { 
  OpenBezier 
  0.1 setflat 
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def 
% 
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def 
% 
/ClosedSymbolBezier { 
  /f ED  % save showpoints value 
  2 copy /yEnd ED /xEnd ED 
  counttomark -2 roll 2 copy /yStart ED /xStart ED 
  counttomark 2 roll 
  f 
  ClosedBezier 
  0.1 setflat 
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def 
% 
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def 
% 
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA 
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def 
% 
/Parab1 { % 1 end  |  0 SP 
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint 
  newpath moveto 
  xSP dx sub ySP dy add x1 y1 ArrowA 
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def 
% 
/Grid { 
  newpath 
  /a 4 string def 
  /b ED %  psk@gridlabels in pt 
  /c ED %  { \pst@usecolor\psgridlabelcolor } 
  /n ED %  psk@griddots 
  cvi dup 1 lt { pop 1 } if 
  /s ED %  \psk@subgriddiv 
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if % \pst@number\psyunit abs 
  /dx ED dy div round dy mul % \pst@number\psxunit abs 
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def 
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def } 
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add 
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt 
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1 
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash } 
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash } 
  % DG/SR modification end 
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def 
% 
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add 
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c 
  mul neg d 
} def 
% 
/Ellipse { 
  /rotAngle ED 
  /mtrx CM def 
  T 
  rotAngle rotate 
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def 
% 
/ArcAdjust { %%%% Vincent Guirardel 
% given a target length (targetLength) and an initial angle (angle0) [in the stack], 
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0). 
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)). 
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0 
% contrary to TvZ's code. 
% To achieve, this, one iterates the following process: start with some angle t, 
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]. 
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned. 
% 
% Another difference with TvZ's code is that we need d (=add/sub) to be defined. 
% the value of d = add/sub is used to know on which side we have to move. 
% It is only used in the initialisation of the angle before the iteration. 
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Input stack:  1: target length 2: initial angle 
% variables used : rx, ry, d (=add/sub) 
% 
  /targetLength ED /angle0 ED 
  /x0 rx angle0 cos mul def 
  /y0 ry angle0 sin mul def 
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t))) 
%initialisation of angle (using 1st order approx = TvZ's code) 
  targetLength 57.2958 mul 
  angle0 sin rx mul dup mul 
  angle0 cos ry mul dup mul 
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees 
% (if the ellipse is very curved at the point where we draw the arrow, % 
% the value can be much more than 360 degrees !) 
% this should avoid going on the wrong side (more than 180 degrees) or go near 
% a bad attractive point (at 180 degrees) 
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub 
% maximum number of times to iterate the iterative procedure: 
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack) 
  30 { dup 
% compute distance D between (x0,y0) and M(t) 
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt 
% if D almost equals targetLength, we stop 
    dup targetLength sub abs 1e-5 le { pop exit } if 
% stack now contains D t 
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]: 
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 ) 
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub 
% stack contains:  y(t)-y0, x(t)-x0, d 
    2 index Div targetLength mul y0 add ry Div exch 
    2 index Div targetLength mul x0 add rx Div 
% stack contains x(t')/rx , y(t')/ry , d 
% now compute t', and remove D from stack 
    atan exch pop 
  } repeat 
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse... 
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case... 
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow 
% to give back the result as a an angle relative to angle0 we could add the following line: 
% angle0 sub 0 exch d 
% 
% begin bug fix 2006-01-11 
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180 
%(we don't want to make the ellipse turn more or less than it should)... 
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse 
% end bug fix 
} def 
% 
/EllipticArcArrow { 
  /d ED      % is add or sub 
  /b ED      % arrow procedure 
  /a1 ED     % angle 
  gsave 
  newpath 
  0 -1000 moveto 
  clip                  % Set clippath far from arrow. 
  newpath 
  0 1 0 0 b             % Draw arrow to determine length. 
  grestore 
% Length of arrow is on top of stack. Next 3 numbers are junk. 
% 
  a1 exch ArcAdjust   % Angular position of base of arrow. 
  /a2 ED 
  pop pop pop 
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig 
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig 
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack. 
  b pop pop pop pop       % Draw arrow, and discard coordinates. 
  a2 CLW 8 div 
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not ) 
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse 
  ArcAdjust 
% resets original value of d 
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap. 
} def 
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%% 
% 
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def 
% 
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def 
% 
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def 
% 
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def 
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def 
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def 
% 
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def 
% 
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def 
% 
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def 
% 
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def 
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def 
  /IfVisible true def 
} def 
% 
%%%%%%%%%%%%%%%%% tools %%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%% ### bubblesort ### 
%% syntax : array bubblesort --> array2 trie par ordre croissant 
%% code de Bill Casselman 
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/ 
/bubblesort { 
4 dict begin 
   /a exch def 
   /n a length 1 sub def 
   n 0 gt { 
      % at this point only the n+1 items in the bottom of a remain to 
      % the sorted largest item in that blocks is to be moved up into 
      % position n 
      n { 
         0 1 n 1 sub { 
            /i exch def 
            a i get a i 1 add get gt { 
               % if a[i] > a[i+1] swap a[i] and a[i+1] 
               a i 1 add 
               a i get 
               a i a i 1 add get 
               % set new a[i] = old a[i+1] 
               put 
               % set new a[i+1] = old a[i] 
               put 
            } if 
         } for 
         /n n 1 sub def 
      } repeat 
   } if 
   a 
end 
} def 
% 
% 
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422 
  0 1 index { length add } forall 
  string 
  0 3 2 roll 
  { 3 copy putinterval length add }forall 
  pop 
} bind def 
% 
% 
end 
%-----------------------------------------------------------------------------% 
% 
% END pstricks.pro 
%%EndProcSet
%%BeginProcSet: pst-algparser.pro
% $Id: pst-algparser.pro 350 2010-06-18 05:18:55Z herbert $ 
%% 
%% PostScript prologue for PSTricks algorithm parser 
%% Version 0.02, 2010/06/08 
%% 
%% This program can be redistributed and/or modified under the terms 
%% of the LaTeX Project Public License Distributed from CTAN archives 
%% in directory macros/latex/base/lppl.txt. 
%% 
%%-----------------------------------------------------------------------------% 
% 
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez 
% 
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin 
% 
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.12 
% E->T|E+T 
% T->FS|T*FS 
% FS -> F | +FS | -FS 
% F->P|F^SF 
% P->(E)|literal 
% literal->number|var|var[E]|func(params) 
% params->E|E,param 
% number->TOBEFINISHED 
% 
%% E expression, T term, SF signed factor, F factor, P power 
% 
%% parser 
% 
%% str 
% 
%% C->E<condition_operators>E 
%% STR index -> STR index+lenExpr 
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def 
% 
%% analyze Expression List (separator , or | ) 
%% STR index -> STR index+lenExpr 
%% /AnalyzeListOfE { 
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar 
%%     NextNonBlankChar dup 0 eq { pop exit } if 
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if 
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop 
%%   AnalyzeListOfEPostHook 
%% } def 
/AnalyzeListOfE { 
  /NotFirst false def 
  { NextNonBlankChar pop AnalyzeExpr 
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse 
    dup Strlen eq { exit } if NextNonBlankChar 
    dup 44 ne 1 index 124 ne and 
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } 
    if  pop 1 add } loop 
  AnalyzeListOfEPostHook 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% E->T|E+T 
%% STR index -> STR index+lenExpr 
/AnalyzeExpr { 
  AnalyzePreHook AnalyzeTerm IsEndingExpr 
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse } 
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop } 
  ifelse 
  AnalyzePostHook 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% T->FS|T*FS 
%% STR index 
/AnalyzeTerm { 
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm 
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse } 
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop } 
  ifelse 
  AnalyzePostHook 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% FS -> F | +FS | -FS 
%% STR index 
/AnalyzeSignedFactor { 
  AnalyzePreHook 2 copy get dup IsUnaryOp 
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp } 
  { pop AnalyzeFactor } 
  ifelse AnalyzePostHook 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% F->P|F^P 
%% STR index 
/AnalyzeFactor { 
  AnalyzePreHook AnalyzePower IsEndingFactor 
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse } 
  { { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower IsEndingFactor { pop exit } if} loop } 
  ifelse  AnalyzePostHook 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% P->(E)|literal 
%% STR index 
/AnalyzePower { 
  %% depending of first char either a number, or a literal 
  2 copy get dup 40 eq%%an open par 
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop } 
  { AnalyzeLiteral } 
  ifelse 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% STR index STR[index] -> STR index 
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def 
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% recognize + or - 
%% chr -> T/F 
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% a number can contain only : 0123456789. 
%% chr -> T/F 
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% STR index -> STR index number 
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)? 
%% STR index -> STR index' number 
/ReadNumber { 
  exch dup 3 -1 roll dup 3 1 roll 
  %%read mantissa 
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop 
  dup 101 eq exch 69 eq or 
  %%% there is a "e" or "E" -> read exponant 
  { 1 add 2 copy get dup IsUnaryOp 
    { pop 1 add 2 copy get } if 
    { IsNumber not { exit } if 1 add 2 copy get } loop } 
  if 
  dup 4 1 roll 
  3 -1 roll exch 1 index sub getinterval 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% a number can contain only : 0123456789. 
%% chr -> T/F 
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% STR index -> STR index number 
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)? 
%% STR index -> STR index' number 
/ReadCondOp { 
  NextNonBlankChar 1 index 4 1 roll 
  { IsCondOp not { exit } if 1 add  2 copy get } loop 
  2 copy 5 -1 roll 
  exch 1 index sub getinterval 3 1 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% a literal can contain only : 0123456789. 
%% chr -> T/F 
/IsLiteral {% 
  dup 48 ge exch dup  57 le 3 -1 roll and exch 
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch 
  dup 97 ge exch     122 le and or } bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)? 
%% STR index -> literal STR index' nextchr 
/ReadLiteral { 
  exch dup 3 -1 roll dup 3 1 roll 
  %%read literal core 
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop 
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% expr is ended by end of str or a clpar 
%% STR index -> STR index STR[index] T/F 
/IsEndingExpr {% 
  2 copy dup Strlen eq 
  %% if end of str is reached -> end ! 
  { pop pop 0 true } 
  %% ending chr -> clpar, comma, |, <, >, =, !, 
  {get dup  dup  41 eq 
       exch dup 124 eq 
       exch dup  93 eq 
       exch dup  44 eq 
       exch dup  30 eq 
       exch dup  60 ge exch 62 le and or or or or or} 
  ifelse } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% expr is ended by end of str or a +- 
%% STR index -> STR index STR[index] T/F 
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% expr is ended by end of str or */ 
%% STR index -> STR index STR[index] T/F 
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% expr is ended by end of str or ^ 
%% STR index -> STR index STR[index] T/F 
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% STR index -> STR index STR[index] 
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def 
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def 
%%%%%%%%%%%%%%%%%%%%%%%% 
%% DEBUG 
/BRK {false} def 
/BRKtrue {/BRK true def} def 
/BRKStop {BRK {BRKtoto} if } def 
/BRKEvalStop {BRK exch if } def 
/BRKBRK2true {BRK {BRK2true} if } def 
/BRK2 {false} def 
/BRK2true {/BRK2 true def} def 
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def 
end 
% 
%-------------------------------------------------------------------------------% 
% 
/tx@AlgToPs 12 dict def tx@AlgToPs begin 
% 
%% algExpr -> PSVector 
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def 
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def 
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def 
/Strlen 0 def 
/EvalListOfExpr {} def% 
/EvalNumber {% 
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx 
    exch 1 add array astore def NextNonBlankChar pop } def 
/EvalAddSub {% 
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll 
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def 
} def 
/EvalMulDiv {% 
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll 
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def 
} def 
/EvalPower {% 
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll 
  pop /exp cvx exch 1 add array astore def 
} def 
/EvalLiteral {% 
  ReadLiteral 
  dup 40 eq%%% there is an open par -> function call 
  { pop 2 index 
    dup (Sum) eq { EvalSum } 
    { dup (IfTE) eq { EvalCond } 
      { dup (Derive) eq { pop EvalDerive } 
{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc 
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx 
  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse } 
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def 
    dup 91 eq%%% there is an open bracket -> vector element 
    { pop 1 add NextNonBlankChar pop AnalyzeExpr 
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add } 
    { pop NextNonBlankChar pop } 
    ifelse} 
  ifelse 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% the derive function : Derive(n,f(x)) 
%% firstparindex lastparindex -> 
/EvalDerive { 
  %% manage the function descripiton 
  1 add ReadNumber 3 1 roll NextNonBlankChar 
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if 
  1 add NextNonBlankChar pop 
  3 -1 roll cvi 
  dup 0 eq 
  { pop AnalyzeExpr 3 -1 roll pop 1 add } 
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll 
    { (x) tx@Derive begin Derive end } repeat 
    ExpressionVector exch /ExpressionVector [] def 
    AlgToPs aload length 
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def 
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add 
    1 index length /Strlen exch def } ifelse 
} def 
/EvalSum {% 
  pop 1 add NextNonBlankChar pop 
  %% read the variable name 
  ReadLiteral pop NextNonBlankChar 
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if 
  %% read the initial value 
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll 
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if 
  %% read the increment value 
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll 
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if 
  %% read the limit value 
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll 
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if 
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll 
  5 -1 roll 4 add array astore def 
  %% keep ExpressionVector for later and create a new one for internal Sum computation 
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def 
  1 add NextNonBlankChar pop AnalyzeExpr 
  %% add each term 
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def 
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add 
  array astore def 3 -1 roll pop 1 add 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Convert to radians if trigo function call 
%% (name) -> 
/TrigoFunc { 
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or 
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add 
    array astore def 
  } if 
} def 
/EvalCond {% 
  pop 1 add AnalyzeCond NextNonBlankChar 
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if 
  ExpressionVector 3 1 roll /ExpressionVector [] def 
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def 
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if 
  1 add AnalyzeExpr 
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if 
  ExpressionVector 
  /ExpressionVector 6 -1 roll aload length dup 
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def 
  1 add 3 -1 roll pop 
} def 
%% CondOp STR index 
/EvalCondOp {% 
  3 -1 roll 
  dup (=) eq  { /eq } {% 
  dup (<) eq  { /lt } {% 
  dup (>) eq  { /gt } {% 
  dup (>=) eq { /ge } {% 
  dup (<=) eq { /ge } {% 
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator } 
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse 
  cvx exch pop 
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def 
/EvalUnaryOp { 
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% H O O K S 
/AnalyzePreHook {} bind def 
/PreEvalHook {} bind def 
/AnalyzeListOfEPostHook {} bind def 
/AnalyzePostHook {} def 
/RollOp { 3 1 roll } bind def 
end   %tx@CoreAnalyzerDict 
% 
%--------------------------------------------------------------------% 
% 
/tx@Derive 41 dict def tx@Derive begin 
%%increase ^^ for each function added 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% algExpr variable -> PSVector 
/Derive {% 
  10240 string 3 1 roll 0 3 1 roll 
  /Variable exch def 
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end 
} def 
/Strlen 0 def 
/InitParser { dup length /Strlen exch def 0 } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% algExpr variable index -> PSVector 
/DeriveIndexed {% 
  3 1 roll 10240 string 3 1 roll 0 3 1 roll 
  /Variable exch def 
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (u,v)'=-(u',v') 
/EvalListOfExpr {% 
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe 
           2 copy 7 -1 roll dup length 4 1 roll putinterval add 
  6 -2 roll pop pop 
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (-u)'=-(u') 
/EvalUnaryOp { 
  4 -2 roll 4 index (0) eq 
  { (0) StrConcat 7 -1 roll pop } 
  { 7 -1 roll 45 eq 
    { AddSub AddOpPar true } { false } ifelse 
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse 
  2 copy pop 0 6 2 roll GetIntervalNewStr 
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (number)'=0 
/EvalNumber { ReadNumber (0) 6 2 roll } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (u+v)'=u'+v' 
/EvalAddSub {% 
  7 index dup (0) eq 
  { pop true }%% du=0 nothing added 
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false } 
  ifelse 
  5 index dup (0) eq 
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0 
  { exch 
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added 
    { 5 -2 roll 7 index 43 eq%%something yet added 
      { AddAdd false } { AddSub AddOpPar true } ifelse } 
    ifelse 11 1 roll 
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if 
    2 copy pop 0 6 2 roll GetIntervalNewStr } 
  ifelse 
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (u*v)' or (u/v)' 
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (u*v)'=u'*v+u*v' 
/EvalMul {% 
  4 -2 roll 7 index dup (0) eq 
  { pop false }%%du=0 
  { (1) eq%%du=1 
    { false } 
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse 
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if 
    true }%%du!=0 
  ifelse 
  5 1 roll 5 index (0) eq 
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0 
  { 5 -1 roll { AddAdd } if 
    4 index (1) eq 
    { 8 index StrConcat } 
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar } 
    ifelse 
  }%%dv!=0 
  ifelse 
  2 copy pop 0 6 2 roll GetIntervalNewStr 
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (u/v)'=(u'*v-u*v')/v^2 
/EvalDiv {% 
  4 -2 roll 
  4 index (0) eq%%dv=0 -> u'/v 
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse } 
  { 7 index dup (0) eq 
    { pop }%%du=0 
    { (1) eq%%du=1 
      { false } 
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse 
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0 
    ifelse 
      AddSub 
      4 index (1) eq 
      { 8 index StrConcat } 
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar } 
      ifelse 
    %}%%dv!=0 
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar 
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add } 
  ifelse 
  2 copy pop 0 6 2 roll GetIntervalNewStr 
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% str1 index str2 -> str1 index 
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def 
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u) 
/EvalPower {% 
  4 -2 roll 7 index (0) eq 
  {%%if du=0 then (u^v)'=v'ln(u)u^v 
    4 index (0) eq 
    { (0) StrConcat }%%if dv=0 then (u^v)'=0 
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if 
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if 
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse 
  } 
  {%%du!=0 
    4 index (0) eq 
    {%%if dv=0 then (u^v)'=vu'u^(v-1) 
      5 index dup IsStrNumber 
      { dup (0) eq 
        { StrConcat } 
        { dup dup (1) eq exch (1.0) eq or 
          { StrConcat  } 
  { StrConcat 
    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1 
    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006 
            (*\() StrConcat 8 index StrConcat (\)) StrConcat 
            5 index  dup dup (2) eq exch (2.0) eq or 
    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse } 
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat 
        5 index StrConcat (-1\)) StrConcat } ifelse 
    } 
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u) 
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if 
      AddOpPar 5 index StrConcat (\)*\() StrConcat 
      8 index StrConcat (\)^\() StrConcat 
      5 index StrConcat (-1\)+\() StrConcat 
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if 
      8 index StrConcat (\)^\() StrConcat 
      5 index StrConcat (\)*ln\() StrConcat 
      8 index StrConcat AddClPar 
    } ifelse 
  } ifelse 
  2 copy pop 0 6 2 roll GetIntervalNewStr 
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% str -> true/false 
/IsStrNumber {% 
  true exch 
  { dup 48 lt exch dup 57 gt 3 -1 roll or 
    exch dup 46 ne%%. 
    exch dup 43 ne%%+ 
    exch 45 ne%%- 
    and and and { pop false } if } forall 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% literal switch -> func call, vector, variables 
/EvalLiteral {% 
  ReadLiteral dup 40 eq%%% there is an open par -> function call 
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec } 
  { dup 91 eq%%% there is an open bracket -> vector element 
    { ERROR_vector_not_yet_implemented } 
    { pop EvalVariable } 
    ifelse } 
  ifelse 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% first last parpos Expr[first:parpos-1] -> 
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% (f(u))'=u'f'(u) 
/EvalFunc { 
  4 2 roll 4 index (1) ne 
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if 
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec 
  2 copy pop 0 6 2 roll GetIntervalNewStr 
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Func derivative -> Eval<func> 
/EvalFunc_sin {% 
  PreCommonFunc 
  { (cos\() StrConcat 5 index StrConcat AddClPar } if 
  PostCommonFunc } def 
/EvalFunc_cos {% 
  PreCommonFunc 
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_tan {% 
  PreCommonFunc 
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_asin {% 
  PreCommonFunc 
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_acos {% 
  PreCommonFunc 
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_atg {% 
  PreCommonFunc 
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_ln {% 
  PreCommonFunc 
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if 
  PostCommonFunc } def 
/EvalFunc_exp {% 
  PreCommonFunc 
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if 
  PostCommonFunc } def 
/EvalFunc_EXP {% 
  PreCommonFunc 
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if 
  PostCommonFunc } def 
/EvalFunc_sqrt {% 
  PreCommonFunc 
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_Fact {% 
  PreCommonFunc { ERROR_no_variable_expression_in_Fact } if 
  PostCommonFunc } def 
/EvalFunc_sh {% 
  PreCommonFunc 
  { (ch\() StrConcat 5 index StrConcat AddClPar } if 
  PostCommonFunc } def 
/EvalFunc_ch {% 
  PreCommonFunc 
  { (sh\() StrConcat 5 index StrConcat AddClPar } if 
  PostCommonFunc } def 
/EvalFunc_th {% 
  PreCommonFunc 
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_Argsh {% 
  PreCommonFunc 
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_Argch {% 
  PreCommonFunc 
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if 
  PostCommonFunc } def 
/EvalFunc_Argth {% 
  PreCommonFunc 
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if 
  PostCommonFunc } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
/PreCommonFunc { 
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop 
  4 2 roll 4 index (0) eq 
  { (0) StrConcat false } 
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse 
} def 
/PostCommonFunc { 
  2 copy pop 0 6 2 roll GetIntervalNewStr 
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
/EvalFunc_Derive {% 
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs 
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add 
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar 
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval 
  exch 6 2 roll } def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% literal switch -> func call, vector, variables 
/EvalFunc_Sum {% 
  1 add NextNonBlankChar pop 
  %% read the variable name 
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar 
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if 
  %% read the initial value 
  1 add NextNonBlankChar pop ReadNumber pop 
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if 
  %% read the increment value 
  1 add NextNonBlankChar pop ReadNumber pop 
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if 
  %% read the limit value 
  1 add NextNonBlankChar pop ReadNumber pop 
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if 
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop 
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat 
  4 index StrConcat AddClPar 
  2 copy pop 0 6 2 roll GetIntervalNewStr 
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% literal switch -> func call, vector, variables 
/EvalFunc_IfTE {% 
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond 
  NextNonBlankChar 
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if 
  1 add NextNonBlankChar pop dup 5 1 roll 
  AnalyzeExpr NextNonBlankChar 
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if 
  1 add NextNonBlankChar pop 
  AnalyzeExpr 1 add NextNonBlankChar pop 
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat 
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar 
  2 copy pop 0 6 2 roll GetIntervalNewStr 
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% advance in str until a comma is found (no error detection!) 
%% str index -> str index' 
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Convert to radians if trigo function call 
%% (name) -> 
/TrigoFunc { 
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or 
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add 
    array astore def 
  } if 
} def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% No derivative for condition.... 
/EvalCondOp { 3 -1 roll pop } bind def 
/PutIntervalOneAdd {putinterval 1 add} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Add open parenthesis in string at the given index 
%% str index -> str index+1 
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Add close parenthesis in string at the given index 
%% str index -> str index+1 
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Add 0 in string at the given index 
%% str index -> str index+1 
/AddZero {2 copy (0) PutIntervalOneAdd} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Add open parenthesis in string at the given index 
%% str index -> str index+1 
/AddMul {2 copy (*) PutIntervalOneAdd} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Add open parenthesis in string at the given index 
%% str index -> str index+1 
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Add a plus sign in string at the given index 
%% str index -> str index+1 
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Add a minus sign in string at the given index 
%% str index -> str index+1 
/AddSub {2 copy (-) PutIntervalOneAdd} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Add a pipe sign in string at the given index 
%% str index -> str index+1 
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% H O O K S 
/AnalyzePreHook { dup 5 1 roll } bind def 
/PreEvalHook {} def 
/AnalyzePostHook { 7 -1 roll pop } bind def 
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def 
/RollOp { 5 1 roll } bind def 
end%%%tx@CoreAnalyzerDict 
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% NEW FUNC 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2)) 
%% x -> theta 
/asin {% 
  dup abs 1 gt { EQDFasinrangeerror  } if 
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad 
} def 
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x) 
%% x -> theta 
/acos {% 
  dup abs 1 gt { EQDFacosrangeerror  } if 
  dup dup mul 1 exch sub sqrt exch atan DegtoRad 
} def 
%% function arctangent in radians 
%% x -> theta 
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def 
%% HYPERBOLIC FUNCTIONS 
/sh { dup Ex exch neg Ex sub 2 div } def 
/ch { dup Ex exch neg Ex add 2 div } def 
/th { dup sh exch ch div } def 
/Argsh { dup dup mul 1 add sqrt add ln } def 
/Argch { dup dup mul 1 sub sqrt add ln } def 
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def 
%% modified exponential funtion for 0 
%% x n -> x^n 
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def 
%% modified exponential funtion for 0 
%% x -> e^x 
/Ex { Euler exch exp } bind def 
%% 
%% factorial function 
%% n -> n! 
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def 
/fact { Fact } bind def 
end 
% 
% END pst-algparser.pro 
%%EndProcSet
%%BeginSetup
tx@Dict
begin

%%EndSetup
STP
0
setlinecap
0
setlinejoin
10
setmiterlimit
[]
0
setdash
newpath
gsave 0.8 SLW 0  setgray 

gsave
0.8
SLW
0

setgray
0.0
0.0
142.26372
85.35823
0.0
0.0
28.45274
abs
28.45274
abs
1
0
{
0

setgray
}
10.0
/Helvetica
findfont
10.0
scalefont
setfont
Grid
grestore

grestore
/ArrowA
{
moveto
}
def
/ArrowB
{
}
def

gsave 2.84544 SLW 0 0 1  setrgbcolor 

0.
true
28.45274
28.45274
113.81097
56.90549
.5
Frame

gsave
2.84544
SLW
0
0
1

setrgbcolor

1.
.setopacityalpha


0

setlinejoin
0

setlinecap
stroke

grestore
grestore
%%Trailer
end
%%EOF
